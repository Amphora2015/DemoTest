//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Timers;
using System.Windows.Forms;
using com.amphora.cayenne.entity;
using com.amphora.cayenne.entity.support;
using com.amphora.entities;
using com.amphora.entities.container;
using com.amphora.entities.dto;
using com.amphora.model;
using DevExpress.XtraBars;
using DevExpress.XtraPivotGrid;
using DevExpress.XtraTab;
using DevExpress.XtraTreeList;
using DevExpress.XtraTreeList.Nodes;
using NSRiskMgrCtrls;
using NSRMCommon;
using NSRMLogging;
using JLIST = java.util.List;
using JMAP = java.util.Map;
using DevExpress.XtraWaitForm;
using System.Threading;
using  org.apache.cayenne;
using System.Linq;


namespace NSRiskManager {

    public partial class RiskManagerForm : IPivotDataProvider,IUomRequester,IWindowLayoutProvider,IPositionContainer,IUomContainer,IPortfolioContainer {
        #region delegates
        delegate int CurrentPortNumHandler();
        delegate void HandleStatusText(BarStaticItem bsi,string msg);
        delegate void PositionResolutionHandler();
        delegate void ZeroParmDelegate();

        delegate void RequestCurrentPivotgridReloadDelegate(string tabName);
        delegate void RequestCurrentPivotgridRedrawDelegate(string tabName); 

        delegate void HandleDeletedPortfolio(JLIST l, string str1, string str2);
        delegate void HandleInsertedPortfolio(JLIST l, JMAP m1, JMAP m2, string str1, string str2);
        delegate void HandleOnPortfolioLoaded(java.util.Collection c);
        delegate void HandleOnPortfolioRemoval(IPortfolioEntityDTO ipedto);
        delegate void HandleUpdatedPortfolio(JLIST l, JMAP m1, JMAP m2, string str1, string str2);
        delegate void HandleSetNumPositionsOnScreen();
        delegate void SetDatasourceDelegate(object sender, List<RiskGroup> ret);
        delegate void SetWindowTitleBasedOnDirtyStatusDelegate();


        #endregion

        #region constants
        const string DEL_CACHE = "Delete Cache Entries";
        #endregion

        #region events
        public event WindowClosingHandler windowClosingEvent;
        #endregion

        #region fields
        static int classInstance = 0;
        List<RiskGroup> pivotGridData;
        Random rnd = null;
        RiskGroup findRiskGroup;
        System.Timers.Timer displayTimer;
        bool autoDeleteCache;
        readonly object pivotDataLock = new object();
        int[] initialPortPathVector = new int[0];
        WinDefContext ctxWindow;
        readonly object dataSourceLock = new object();
       
        Dictionary<string, List<int>> portIdToNodeIDMapping = new Dictionary<string, List<int>>();
        Random randomGenerator = new System.Random();


        private int maxSeqNum = 1;
        java.lang.Integer[] latestPortfoliosForSubscription;

        
        private bool screenInitiallyLoaded = false;
        private bool newWindowOpening = false;
        private bool firstTimeTabPageChanged = false;
        
        const int MILLISECONDS_FOR_TIMER = 5000;
        private bool isInitialReloadForPortfolio = false;

        static object loadDataLock = new object();
        static object myLock = new object();

       


        public bool getTabReDrawStatus(string tabName)
        {

            foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
            {
                if (xtraTabPage is TabPageWithUomPivot)
                {
                    TabPageWithUomPivot uomPivotPage = ((TabPageWithUomPivot)xtraTabPage);

                    if (uomPivotPage.Text == tabName)
                    {
                        return uomPivotPage.isMarkedForRedraw;

                    }
                }
            }
            return false;

          
        }


        public void setTabReDrawStatus(string tabName, bool status)
        {
               foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages) 
               {
                    if (xtraTabPage is TabPageWithUomPivot) 
                    {
                        TabPageWithUomPivot uomPivotPage = ((TabPageWithUomPivot) xtraTabPage);

                        if(uomPivotPage.Text == tabName)
                        {
                            uomPivotPage.isMarkedForRedraw = status;
                            
                        }
                    }
                }

         
          
        }


        public bool getTabReLoadStatus(string tabName)
        {

             foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
             {
                if (xtraTabPage is TabPageWithUomPivot) 
                {
                    TabPageWithUomPivot uomPivotPage = ((TabPageWithUomPivot) xtraTabPage);

                    if(uomPivotPage.Text == tabName)
                    {
                        return uomPivotPage.isMarkedForReload;
                        
                    }
                }
             }
             return false;

          

        }

        public void setTabReLoadStatus(string tabName, bool status)
        {

            foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
            {
                if (xtraTabPage is TabPageWithUomPivot)
                {
                    TabPageWithUomPivot uomPivotPage = ((TabPageWithUomPivot)xtraTabPage);

                    if (uomPivotPage.Text == tabName)
                    {
                        uomPivotPage.isMarkedForReload = status;
                        
                    }
                }
            }
            

          
        }

      

        #endregion

        #region ctors

        int initialPortfolioId;

        public RiskManagerForm() : this(null, false, 0) { }
        BackgroundWorker riskForm_worker;

        public RiskManagerForm(WinDefContext wdc, bool isNewWindow, int initialPortfolioId) {

            forcingInitialSelection = true;
            newWindowOpening = isNewWindow;
            this.windowInstance = ++classInstance;
            ctxWindow = wdc;
            InitializeComponent();
            if (ctxWindow != null)
            {
                this.Text = this.formName = wdc.windowDefinition.getWindowTitle();
            }
            riskForm_worker = new BackgroundWorker();
            riskForm_worker.DoWork += new DoWorkEventHandler(riskForm_worker_DoWork);
            riskForm_worker.WorkerReportsProgress = false;
            riskForm_worker.WorkerSupportsCancellation = true;
            this.initialPortfolioId = initialPortfolioId;                    
         
          
        }

        #endregion ctors

        #region IPivotDataProvider implementation
      
        
        object IPivotDataProvider.pivotGridData2 
        {
          get 
          { 
                return this.pivotGridData; 
          } 
        }

        object IPivotDataProvider.findDistributions(int[] positionNums, Dictionary<int, char> positionTypes, Dictionary<int, string> commodityCodes, Dictionary<int, string> originalUOMs, int decimalPrecision, string UOM, bool equivIndChecked) 
        {
            return SharedContext.readDistributions(positionNums, positionTypes, commodityCodes, originalUOMs, decimalPrecision, UOM, equivIndChecked);
        }

        #endregion IPivotDataProvider implementation

        #region properties
        public string formName { get; set; }
        public WrappedWinDef windowDef { get { if (ctxWindow == null) throw new InvalidOperationException("context is null!"); return ctxWindow.wrappedDef; } }
        public int windowInstance { get; private set; }
        #endregion

        #region IUomRequester
        object IUomRequester.desiredUoms() { return SharedContext.readUoms(); }
        #endregion IUomRequester

        #region methods

        #region overridden methods
        protected override void OnClosing(CancelEventArgs e) {

            if (!e.Cancel) 
            {
                stopDisplayTimer();
                saveLayoutToDatabase();
                doShutdown();
                
                if (this.windowClosingEvent != null)
                    this.windowClosingEvent(this,new WindowClosingEventArgs(this.formName, this.windowDef.windowId));
               

            }
            base.OnClosing(e);

        }

        #endregion

        #region IWindowLayoutProvider implementation

        int IWindowLayoutProvider.portSplitPosition
        {
            get { return this.splitContainerControl1.SplitterPosition; }
            set { this.splitContainerControl1.SplitterPosition = value; }
        }

        int IWindowLayoutProvider.lowerSplitPosition
        {
            get { return this.inspectablePivotGrid1.lowerSplitPosition; }
            set { this.inspectablePivotGrid1.lowerSplitPosition = value; }
        }

        int IWindowLayoutProvider.pnlSplitPosition
        {
            get { return this.inspectablePivotGrid1.pnlSplitPosition; }
            set { this.inspectablePivotGrid1.pnlSplitPosition = value; }
        }

        Rectangle IWindowLayoutProvider.windowFrame
        {
            get { return this.DesktopBounds; }
            set { if (!Rectangle.Empty.Equals(value)) this.DesktopBounds = value; }
        }

        string IWindowLayoutProvider.selectedPortfolioPath
        {
            get { return getSelectedPortfolioPath(this.treeList1); }
            set { initialPortPathVector = convertStringToIntVector(value); }
        }
        #endregion IWindowLayoutProvider implementation

     

        #region action methods

        bool riskManagerFormLoaded = false;
        DevExpress.XtraBars.Bar statusBar;
        BarStaticItem statusBarStaticItem;
        BarStaticItem rabbitMqStatusLabel;
        BarStaticItem rabbitMqStatusIcon;
        public void setStatusBarMessage(string message, bool isSuccess)
        {
            statusBarStaticItem.Caption = message;
            if(isSuccess)
                statusBarStaticItem.ItemAppearance.Normal.ForeColor = System.Drawing.Color.Black;
            else
                statusBarStaticItem.ItemAppearance.Normal.ForeColor = System.Drawing.Color.Red;
        }

        private void createToolBar()
        {
            BarManager barManager = new BarManager();
            barManager.Form = this;
            // Prevent excessive updates while adding and customizing bars and bar items.
            // The BeginUpdate must match the EndUpdate method.
            barManager.BeginUpdate();
           
            // Bar1 - is a main menu, which is stretched to match the form's width.
            Bar bar1 = new Bar(barManager, "My MainMenu");
       
            bar1.DockStyle = BarDockStyle.Top;
    
            // Position the bar1 above the bar2
            bar1.DockRow = 0;
            // The bar1 must act as the main menu.
            barManager.MainMenu = bar1;

            // Create bar items for the bar1 and bar2
            BarSubItem RiskViewBarSubItem = new BarSubItem(barManager, "Risk View");
            BarSubItem WindowsBarSubItem = new BarSubItem(barManager, "Windows");
            BarSubItem AboutBarSubItem = new BarSubItem(barManager, "About");

            BarButtonItem buttonNew = new BarButtonItem(barManager, "New");
            BarButtonItem buttonOpen = new BarButtonItem(barManager, "Open");
            BarButtonItem buttonOpen2 = new BarButtonItem(barManager, "Open By Portfolio Number");
           
            BarButtonItem buttonSave = new BarButtonItem(barManager, "Save");
            BarButtonItem buttonSaveAs = new BarButtonItem(barManager, "Save As");
            BarButtonItem buttonExit = new BarButtonItem(barManager, "Close Window");
            BarButtonItem buttonExitAll = new BarButtonItem(barManager, "Quit");
            BarButtonItem buttonArrange = new BarButtonItem(barManager, "Arrange");
            BarButtonItem buttonManage= new BarButtonItem(barManager, "Manage Your Forms");
            BarButtonItem buttonAbout = new BarButtonItem(barManager, "About");

            RiskViewBarSubItem.AddItems(new BarItem[] { buttonNew, buttonOpen,buttonOpen2, buttonSave, buttonSaveAs, buttonExit, buttonExitAll });
            WindowsBarSubItem.AddItems(new BarItem[] { buttonArrange, buttonManage });
         
            //Add the sub-menus to the bar1
            bar1.AddItems(new BarItem[] { RiskViewBarSubItem, WindowsBarSubItem, AboutBarSubItem });

            // A handler to process clicks on bar items
            barManager.ItemClick += new ItemClickEventHandler(barManager_ItemClick);
           
            statusBar = new DevExpress.XtraBars.Bar(barManager);
           
            statusBar.BarName = "StatusBar";
            statusBarStaticItem = new BarStaticItem();

            rabbitMqStatusLabel = new BarStaticItem();
            this.rabbitMqStatusLabel.Caption = "Realtime updates:";
            this.rabbitMqStatusLabel.Alignment = BarItemLinkAlignment.Right;
            this.rabbitMqStatusLabel.Border = DevExpress.XtraEditors.Controls.BorderStyles.NoBorder;
            this.rabbitMqStatusLabel.ItemAppearance.Normal.ForeColor =Color.Black;

            rabbitMqStatusIcon = new BarStaticItem();
            this.rabbitMqStatusIcon.PaintStyle = BarItemPaintStyle.CaptionGlyph;
            this.rabbitMqStatusIcon.Alignment = BarItemLinkAlignment.Right;
            this.rabbitMqStatusIcon.Border = DevExpress.XtraEditors.Controls.BorderStyles.NoBorder;
            this.rabbitMqStatusIcon.TextAlignment = StringAlignment.Far;
            this.rabbitMqStatusIcon.Name = "rabbitMqStatusIcon";
            this.rabbitMqStatusIcon.Enabled = true;
            string assemblyPath = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
            this.rabbitMqStatusIcon.Glyph = global::NSRiskManager.Properties.Resources.Connected;//new Bitmap(assemblyPath + "/art/Connected.ico"); ;//
            this.rabbitMqStatusIcon.GlyphDisabled = global::NSRiskManager.Properties.Resources.DisConnected;// new Bitmap(assemblyPath + "/art/DisConnected.ico");;//
           
            statusBar.ItemLinks.Add(statusBarStaticItem);
            statusBar.ItemLinks.Add(rabbitMqStatusLabel);
            statusBar.ItemLinks.Add(rabbitMqStatusIcon);
            barManager.StatusBar = this.statusBar;
            barManager.EndUpdate();
        }

        void barManager_ItemClick(object sender, ItemClickEventArgs e)
        {
            BarSubItem subMenu = e.Item as BarSubItem;

            switch (e.Item.Caption)
            {
                case "New":
                    RiskManagerWindowManager.createNewWindow();
                    break;
                case "Open":
                    RiskManagerWindowManager.openExistingWindow();
                    break;
                case "Open By Portfolio Number":
                    RiskManagerWindowManager.openNewWindowByPortfolioNum();
                    break;
                case "Save":
                    RiskManagerWindowManager.saveWindow(this.windowDef.windowId);
                    break;
                case "Save As":
                    RiskManagerWindowManager.saveWindowAs(this.windowDef.windowTitle, this.windowDef.windowId);
                    break;
                case "Close Window":
                    RiskManagerWindowManager.closeWindowForm(this.windowDef.windowId);
                    break;
                case "Quit":
                    RiskManagerWindowManager.quitApplicationCompletely();
                    break;
                case "Arrange":
                    RiskManagerWindowManager.arrangeWindows();
                    break;
                case "Manage Your Forms":
                    RiskManagerWindowManager.manageExistingWindows();
                    break;
                case "About":
                    RiskManagerWindowManager.showAboutBox();
                    break;

                
            }

        }
        public string localStorePath =  Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Amphora_RiskManager\\";

        //DefaultValues
        private int _lower_split_pos = 317;
        private int _port_split_pos = 294;
        private int _pnl_split_pos = 541;
        private string _window_frame = "{X=0,Y=0,Width= 1180 ,Height= " + (System.Windows.Forms.Screen.PrimaryScreen.Bounds.Height - 100).ToString() + "}";
        
        void formLoad(object sender,EventArgs ea) 
        {

            createToolBar();
           
            firstTimeTabPageChanged = true;
            
            string tmp;
            Rectangle r;

            treeList1.OptionsBehavior.DragNodes = true;

            rnd = new Random(DateTime.Now.Millisecond);
            lock (pivotDataLock)
                this.pivotGridData = new List<RiskGroup>();
            autoDeleteCache = WindowPositionHelper.readRegistryBool(Application.UserAppDataRegistry,DEL_CACHE);

            this.treeList1.SelectImageList = treeList1.StateImageList = getTreeListImages();

            var LinkImage = Properties.Resources.LinkIcon;
            this.treeList1.Painter.NodeDragImages.Images.Add(LinkImage);

            inspectablePivotGrid1.uomRequester = this;
            inspectablePivotGrid1.InspectorExpanded += inspectablePivotGrid1_InspectorExpanded;
            inspectablePivotGrid1.SelectedPageChanged += inspectablePivotGrid1_SelectedPageChanged;
            inspectablePivotGrid1.pivotDataType = typeof(RiskGroup);
            inspectablePivotGrid1.dataProvider = (IPivotDataProvider) this;
            inspectablePivotGrid1.TabRenamed += inspectablePivotGrid1_TabRenamed;
            inspectablePivotGrid1.newTabAdded += inspectablePivotGrid1_newTabAdded;
            inspectablePivotGrid1.createPivotDef += inspectablePivotGrid1_createPivotDef;
            inspectablePivotGrid1.updatePivotDef += inspectablePivotGrid1_UpdatePivotDefEvent;
            inspectablePivotGrid1.deleteTab += inspectablePivotGrid1_deleteTab;
            inspectablePivotGrid1.restoreSerializedTabs(this.windowDef,true);
            
            if (windowDef != null) 
            {
                if (initialPortfolioId  > 0)
                    initialPortPathVector = getPortfolioPathFromInitialPortfolioId(initialPortfolioId);

                else if (!string.IsNullOrEmpty(windowDef.portfolioPath))
                    initialPortPathVector = Util.makeIntVector(windowDef.portfolioPath);

                this.Text = string.IsNullOrEmpty(windowDef.windowTitle) ? WrappedWinDef.WINDOW_NAME : windowDef.windowTitle;
            }


           

            List<RiskManagerWindowState> lstRMStateWindow = new List<RiskManagerWindowState>();
            try
            {
                if (!Directory.Exists(localStorePath))
                    Directory.CreateDirectory(localStorePath);
                if (File.Exists(localStorePath + "ListOfRiskManagerWindowsXml.xml"))
                {
                    System.Xml.Serialization.XmlSerializer reader = new System.Xml.Serialization.XmlSerializer(typeof(List<RiskManagerWindowState>));
                    using (var wfile = new System.IO.StreamReader(localStorePath + "ListOfRiskManagerWindowsXml.xml"))//reading from local store xml
                    {
                        lstRMStateWindow = (List<RiskManagerWindowState>)reader.Deserialize(wfile);
                        wfile.Close();
                    }
                }
            }
            catch (Exception eex)
            {
            }
            if (lstRMStateWindow != null && lstRMStateWindow.Count > 0)
            {
                foreach (RiskManagerWindowState rmState in lstRMStateWindow)
                {
                    if (this.windowDef != null && rmState.win_id == this.windowDef.windowId)
                    {
                        if (rmState.port_split_pos > 0)
                            ((IWindowLayoutProvider)this).portSplitPosition = rmState.port_split_pos;
                        else
                            ((IWindowLayoutProvider)this).portSplitPosition = this._port_split_pos;

                        if (rmState.pnl_split_pos > 0)
                            ((IWindowLayoutProvider)this).pnlSplitPosition = rmState.pnl_split_pos;
                        else
                            ((IWindowLayoutProvider)this).pnlSplitPosition = this._pnl_split_pos;

                        if (rmState.lower_split_pos > 0)
                            ((IWindowLayoutProvider)this).lowerSplitPosition = rmState.lower_split_pos;
                        else
                            ((IWindowLayoutProvider)this).lowerSplitPosition = this._lower_split_pos;

                        if (!string.IsNullOrEmpty(tmp = rmState.window_frame))
                        {
                            if (!Rectangle.Equals(Rectangle.Empty, r = WindowPositionHelper.makeRectangle(tmp)))
                            {
                                this.DesktopBounds = r;
                            }
                        }
                        else
                        {
                            if (!string.IsNullOrEmpty(tmp =  this._window_frame))
                            {
                                if (!Rectangle.Equals(Rectangle.Empty, r = WindowPositionHelper.makeRectangle(tmp)))
                                {
                                    this.DesktopBounds = r;
                                }
                            }
                        }
                        break;
                    }
                }
            }
            else
            {
                ((IWindowLayoutProvider)this).portSplitPosition = this._port_split_pos;
                ((IWindowLayoutProvider)this).pnlSplitPosition = this._pnl_split_pos;
                ((IWindowLayoutProvider)this).lowerSplitPosition =this._lower_split_pos;
                if (!string.IsNullOrEmpty(tmp = this._window_frame))
                {
                    if (!Rectangle.Equals(Rectangle.Empty, r = WindowPositionHelper.makeRectangle(tmp)))
                    {
                        this.DesktopBounds = r;
                    }
                }
            }
              
            if (windowDef.selectedIndex >= 0)
                    inspectablePivotGrid1.tabControl.SelectedTabPageIndex = windowDef.selectedIndex;

            firstTimeTabPageChanged = false;
            loadData();

            if (windowDef != null)
            {
                windowDef.saveChangesWithoutPrompting();
                windowDef.doWindowUpdate();

            }
            this.SizeChanged += new EventHandler(RiskManagerForm_SizeChanged);
            this.LocationChanged += new EventHandler(RiskManagerForm_LocationChanged);
            if (this.inspectablePivotGrid1 != null && this.inspectablePivotGrid1.scPivotAndLower != null)
                this.inspectablePivotGrid1.scPivotAndLower.SizeChanged += new EventHandler(scPivotAndLower_SizeChanged);
            if (this.inspectablePivotGrid1 != null && this.inspectablePivotGrid1.xtraTabControl1 != null)
                this.inspectablePivotGrid1.xtraTabControl1.SizeChanged += new EventHandler(xtraTabControl1_SizeChanged);
            riskManagerFormLoaded = true;
           
        }


        private bool HasCycle(LocalPortfolio dragNode, LocalPortfolio targetNode)
        {
            int node1PortfolioId = dragNode.portNum;
            int node2PortfolioId = targetNode.portNum;

            var portfolioSupport = PortfolioEntityDTOSupportImpl.Builder.portfolioSupport();
            JMAP ancestors1 = portfolioSupport.findAncestorTreeMultipleParents(new java.lang.Integer(node1PortfolioId));
            JMAP ancestors2 = portfolioSupport.findAncestorTreeMultipleParents(new java.lang.Integer(node2PortfolioId));

        
            List<int> list1 = new List<int>();
            List<int> list2 = new List<int>();
            
            var parents1 = ancestors1.keySet().toArray();
            foreach (java.lang.Integer parent1 in parents1)
            {
                list1.Add(parent1.intValue());
            }

           
            var parents2 = ancestors2.keySet().toArray();
            foreach (java.lang.Integer parent2 in parents2)
            {
                list2.Add(parent2.intValue());
            }
          

            List<int> results = list1.Intersect<int>(list2).ToList<int>();

            //return (results.Count > 0);

            return (list2.Contains(node2PortfolioId));
        }

        int[] findAllParentsForPortfolio(int portfolioId)
        {
            var portfolioSupport = PortfolioEntityDTOSupportImpl.Builder.portfolioSupport();
            List<int> parentsToReturn = new List<int>();


            // map returned has parent as key and child as value
            JMAP ancestors = portfolioSupport.findAncestorTreeMultipleParents(new java.lang.Integer(portfolioId));

            var parents = ancestors.keySet().toArray();
            foreach (java.lang.Integer parent in parents)
            {
                java.lang.Integer child = ancestors.get(parent) as java.lang.Integer;

                if (child.intValue() == portfolioId)
                {
                    parentsToReturn.Add(parent.intValue());
                }
            }

            if (parentsToReturn.Count == 0)
                parentsToReturn.Add(Int32.MinValue);

            return parentsToReturn.ToArray();
        }

        int[] getPortfolioPathFromInitialPortfolioId(int portfolioId)
        {
           

            var portfolioSupport = PortfolioEntityDTOSupportImpl.Builder.portfolioSupport();

            JMAP ancestors = portfolioSupport.findAncestorTree(new java.lang.Integer(portfolioId));
            List<int> portfolioPathToReturn = new List<int>();

            
            if (ancestors.size() == 0)
            {

                portfolioPathToReturn.Add(portfolioId);
                return portfolioPathToReturn.ToArray();
            }
         

            portfolioPathToReturn.Add(portfolioId);

            var currentChild = portfolioId;

            int depth = 0;

            do
            {
                java.lang.Integer ancestor = ancestors.get(new java.lang.Integer(currentChild)) as java.lang.Integer;

                if (ancestor == null)
                    break ;

                currentChild = ancestor.intValue();


                portfolioPathToReturn.Add(currentChild);

                depth++;

            } while (true && depth < 100); //limit depth to 100 to prevent infinite loops;

            portfolioPathToReturn.Reverse();

            return portfolioPathToReturn.ToArray();

        }


        void inspectablePivotGrid1_deleteTab(object sender,string tabName) {
            foreach (WrappedWinPivotDef wwpd in windowDef.allPivotDefinitions()) {
                if (string.Compare(wwpd.tabName,tabName,true) == 0) 
                {
                    windowDef.WindowDefinition.getObjectContext().deleteObject(wwpd.pivotDefinition);
                    break;
                }
            }
        }

        WrappedWinPivotDef inspectablePivotGrid1_createPivotDef(object sender, string name)
        {
            return new WrappedWinPivotDef().createDefault(name, this.windowDef.WindowDefinition.getObjectContext());
        }

        void inspectablePivotGrid1_UpdatePivotDefEvent(object sender, string tabName,bool showProgressIcon)
        {
            if(showProgressIcon)
                this.inspectablePivotGrid1.addPositionPivotGridProgressPanel();
                foreach (WrappedWinPivotDef pivotDefinition in windowDef.allPivotDefinitions())
                 if (string.Compare(pivotDefinition.tabName, tabName, true) == 0) 
                 {
                     this.inspectablePivotGrid1.UpdatePivotDefinitionForTab(pivotDefinition, tabName);
                 }
            if(showProgressIcon)
                this.inspectablePivotGrid1.removePositionPivotProgressPanel();
        }

        void inspectablePivotGrid1_newTabAdded(object sender,WrappedWinPivotDef aPivotDef) {
            this.windowDef.addPivotDefinition(aPivotDef);
        }

        void inspectablePivotGrid1_TabRenamed(object sender,string oldName,string newName) {
            bool found = false;
            foreach (WrappedWinPivotDef adef in this.windowDef.allPivotDefinitions()) {
                if (string.Compare(adef.tabName,oldName,true) == 0) {
                    adef.tabName = newName;
                    found = false;
                    break;
                }
            }
            if (!found)
                Util.show(MethodBase.GetCurrentMethod(),"window '" + oldName + "' not found!");
        }

        void inspectablePivotGrid1_InspectorExpanded(object sender,ExpandedInspectorArgs e) {
            
            
            if(e.expanded) 
            {
                this.stopDisplayTimer();
            } 
            else 
            {
                this.startDisplayTimer();
            }
             
        }

        void treeList1_FocusedNodeChanged(object sender,FocusedNodeChangedEventArgs e) 
        {

            //don't do anything while loading is in progress - we don't want to trigger any events
            if (portfolioHierarchyLoading) 
            {
                this.treeList1.SetFocusedNode(null);
  
                return;
            }

            TreeList tl;
            if (!forcingInitialSelection) 
            {
                tl = sender as TreeList;
                lock (pivotDataLock)
                    pivotGridData.Clear();
               
                treelistSelectionChanged(e);
            }
        }

        void inspectablePivotGrid1_SelectedPageChanged(object sender,TabPageWithUomPivot newPage) 
        {
            if (newPage != null) 
            {
                setupUI(newPage.pivotGrid);
                newPage.setUpUOM(); 

                // we want to ignore the first load event
                if (!firstTimeTabPageChanged)
                { 
                   
                    windowDef.selectedIndex = this.inspectablePivotGrid1.tabControl.SelectedTabPageIndex;
                }

            }
        }

        void cmsPortfolios_Opening(object sender,CancelEventArgs e) 
        {
            LocalPortfolio lp;
            bool enabled = true, enableDelete = true; 

            if ((lp = selectedNodeIn(this.treeList1)) != null)
            {
                enabled = string.Compare(lp.portType, "R") != 0;

            } else
                enabled = false;

            this.ctxNewPortfolio.Enabled = enabled;
            this.ctxNewAsCopyOf.Enabled = true;
            this.ctxUpdatePortfolio.Enabled = true;
            this.ctxDeletePortfolio.Enabled = enableDelete;
        }

        void ctxNewPortfolio_Click(object sender,EventArgs e) {
            createPortfolio(PortfolioEditAction.NEW);
        }

        void ctxNewAsCopyOf_Click(object sender,EventArgs e) 
        {
            createPortfolio(PortfolioEditAction.NEW_AS_COPY_OF);
        }

        void ctxUpdatePortfolio_Click(object sender, EventArgs e)
        {
            try
            {
                LocalPortfolio lp;
                PortfolioEditor pe;
                DialogResult dr;
                string portfolioPath;

                if ((lp = selectedNodeIn(this.treeList1)) != null)
                {
                    portfolioPath = findSelectedPortfolioPath(this.treeList1, true);

                    pe = new PortfolioEditor(PortfolioEditAction.UPDATE, lp.realPortfolio, findParentPortNum(this.treeList1), portfolioPath, lp.IsLinkedIndicator, lp.PortfolioTags);

                    dr = pe.ShowDialog();
                    if (dr.Equals(DialogResult.OK))
                        setStatusBarMessage("Portfolio updated successfully.", true);
                    else if (dr.Equals(DialogResult.Cancel))
                        setStatusBarMessage("Portfolio update cancelled.", true);
                }
            }
            catch (Exception exp)
            {
                setStatusBarMessage(exp.Message, false);
            }
        }


        void ctxDeletePortfolio_Click(object sender, EventArgs e)
        {
            try
            {
                LocalPortfolio lp;
                PortfolioDTO pdto;
                DialogResult result;
                int portNum;

                if ((lp = selectedNodeIn(this.treeList1)) != null)
                {
                    if ((result = MessageBox.Show(
                        this,
                        "Really delete portfolio " + (portNum = lp.portNum) + " [" + lp.portShortName + "]",
                        "Confirm portfolio deletion", MessageBoxButtons.YesNo)) == DialogResult.Yes)
                    {

                        pdto = new PortfolioDTO();
                        pdto.setPortNum(new java.lang.Integer(lp.portNum));
                        pdto.setParentPortId(new java.lang.Integer(lp.parentId));
                        pdto.setLinkInd(lp.IsLinkedIndicator);

                        PortfolioEntityDTOSupportImpl.Builder.portfolioSupport().sendDelete(pdto);
                        setStatusBarMessage("Portfolio: " + portNum + " deleted.", true);
                    }
                    else if (result.Equals(DialogResult.Cancel) || result.Equals(DialogResult.No))
                        setStatusBarMessage("Portfolio: " + portNum + " deletion cancelled.", true);

                }
            }
            catch (Exception exp)
            {
                setStatusBarMessage(exp.Message, false);
            }
        }

        

        void treeList1_GetSelectImage(object sender,GetSelectImageEventArgs e) {
            e.NodeImageIndex = -1;

           LocalPortfolio lp;          
            TreeList tl;

            TreeListNode node = e.Node;

            if ((tl = sender as TreeList) != null) 
            {
              
                if ((lp = node.GetValue("Data") as LocalPortfolio) != null)
                {

                    if (lp.IsLinkedIndicator == "Y")
                        e.NodeImageIndex = 0;

                }
                
            }
        }
        #endregion action methods


        private ImageList getTreeListImages()
        { 
             var LinkImage = Properties.Resources.LinkIcon;
             ImageList List = new ImageList();
             List.Images.Add(LinkImage);

             return List;
        }

      

        #region timer methods

        private void RedrawOrReloadGrid()
        {

            XtraTabPage xtraTabPage = this.inspectablePivotGrid1.tabControl.SelectedTabPage;

            if (xtraTabPage is TabPageWithUomPivot)
            {
                TabPageWithUomPivot uomPivotPage = xtraTabPage as TabPageWithUomPivot;

                string tabName = uomPivotPage.Text;

                bool reloadStatus = getTabReLoadStatus(tabName);
                if (reloadStatus == true)
                {
                    requestCurrentPivotgridReload(tabName);
                }
                else
                {
                    bool redrawStatus = getTabReDrawStatus(tabName);

                    if (redrawStatus)
                    {
                        // reset tab redraw status so that the cells when drawing themselves
                        // can decide if next redraw is required or not
                        //setTabReDrawStatus(tabName, false);
                        requestCurrentPivotGridRedraw(tabName);
                    }

                }

            } 
           
        }

        void displayTimer_Elapsed(object sender,ElapsedEventArgs e) 
        {

            try
            {
                rabbitMQStatusChecking();
                SetWindowTitleBasedOnDirtyStatus();
                RedrawOrReloadGrid();
            }
            catch (Exception ex)
            { 
            }
          
        }

        private void SetWindowTitleBasedOnDirtyStatus()
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new SetWindowTitleBasedOnDirtyStatusDelegate(SetWindowTitleBasedOnDirtyStatus));
            }
            else
            {
                if (windowDef.CheckForContextChanges() == true)
                {
                    this.Text = this.windowDef.windowTitle + "*";
                }
                else
                {
                    this.Text = this.windowDef.windowTitle;
                }
            }
        }

      

        #endregion

        #region other methods

        public void startDisplayTimer()
        {

                if (displayTimer == null) 
                {
                    displayTimer = new System.Timers.Timer(MILLISECONDS_FOR_TIMER);
                    displayTimer.Elapsed += displayTimer_Elapsed;
                    displayTimer.Enabled = true;
                }
    
        }

        public void stopDisplayTimer() 
        {
        
            if (displayTimer != null)
            {
                displayTimer.Enabled = false;
                displayTimer.Elapsed -= displayTimer_Elapsed;
                displayTimer.Dispose();
                displayTimer = null;
            }
   
        }

        void requestCurrentPivotgridReload(string tabName) 
        {
            if (this.disposed)
                return;
            if (this.InvokeRequired)
                this.Invoke(new RequestCurrentPivotgridReloadDelegate(requestCurrentPivotgridReload), tabName);
            else {

                setTabReDrawStatus(tabName, false);
                
                
                TabPageWithUomPivot uomPage = this.inspectablePivotGrid1.tabControl.SelectedTabPage as TabPageWithUomPivot;

                uomPage.pivotGrid.BeginUpdate();
                uomPage.pivotGrid.RefreshData();
                this.inspectablePivotGrid1.tabControl.SelectedTabPage.Refresh();
                uomPage.pivotGrid.EndUpdate();

                //uomPage.setAllRiskGroupsInTabDirty(false);
                setTabReLoadStatus(tabName, false);

                this.inspectablePivotGrid1.removePositionPivotProgressPanel();
            }

        
        }


        void requestCurrentPivotGridRedraw(string tabName)
        {
            if (this.disposed)
                return;
            if (this.InvokeRequired)
                this.Invoke(new RequestCurrentPivotgridReloadDelegate(requestCurrentPivotGridRedraw), tabName);
            else
            {
                setTabReDrawStatus(tabName, false);

                //set the redraw status before as it may be changed by the grid itself - it cases currently 
                // hightlighted cells need to be repainted without highlighting
                //force the grid to redraw
                

                this.inspectablePivotGrid1.tabControl.SelectedTabPage.Refresh();

                TabPageWithUomPivot uomPage = this.inspectablePivotGrid1.tabControl.SelectedTabPage as TabPageWithUomPivot;
                
                uomPage.setAllRiskGroupsInTabDirty(false);

                setTabReLoadStatus(tabName, false);

                this.inspectablePivotGrid1.removePositionPivotProgressPanel();
                
            }

            
        }

        bool findThisRiskGroup(RiskGroup rg) {
            return findRiskGroup.Equals(rg);
        }

        static string getSelectedPortfolioPath(TreeList tl) {
            StringBuilder sb = null;
            List<int> intq;

            if (tl != null) {
                intq = new List<int>();
                foreach (TreeListNode tln in tl.Selection)
                    findSelectedPortfolios(tln,intq);

                if (intq.Count > 0) {
                    sb = new StringBuilder();
                    for (int i = 0 ;i < intq.Count ;i++) {
                        if (sb.Length > 0)
                            sb.Append(AmphoraFieldSelector.DATA_SEP);
                        sb.Append(intq[i].ToString());
                    }
                }
            }
            return sb == null ? string.Empty : sb.ToString();
        }

        static void findSelectedPortfolios(TreeListNode tln,List<int> q) {
            LocalPortfolio lp;
            TreeListNode tln2;

            if ((lp = tln.GetValue("Data") as LocalPortfolio) != null)
            {
                q.Insert(0,lp.portNum);
                if ((tln2 = tln.ParentNode) != null)
                    findSelectedPortfolios(tln2,q);
            }
        }

        private int[] getRealChildrenPortfolios(java.lang.Integer portId)
        {

            List<int> childPortIds = new List<int>();

            var portfolioSupport = PortfolioEntityDTOSupportImpl.Builder.portfolioSupport();

            var realPortfolios = portfolioSupport.findAllRealPortfolioIdFromParentId(portId);

            Array realPortfolioArray = realPortfolios.toArray();

            foreach(java.lang.Integer realPortfolioID in realPortfolioArray)
            {
                int realPortId = realPortfolioID.intValue();

                childPortIds.Add(realPortId);
            }

            return childPortIds.ToArray();

        }

        private void setRealPortfolioCountOnScreen()
        {

            if (this.inspectablePivotGrid1 == null || this.inspectablePivotGrid1.tabControl == null || this.inspectablePivotGrid1.tabControl.TabPages == null)
                return;

            var tabPages = this.inspectablePivotGrid1.tabControl.TabPages;
           

            //once we have multiple tabs, this implementation needs to change to have separete count for each tab
            foreach (XtraTabPage xtp in tabPages)
            {
                if (xtp is TabPageWithUomPivot)
                {
                   var tabPage = xtp as TabPageWithUomPivot;
                   tabPage.setNumberRealPortfolios(this.inspectablePivotGrid1.NumRealPortfoliosOnScreen);

                }
            }
        }


        private void setNumPositionsOnScreen()
        {
            if (InvokeRequired)
            {
                this.Invoke(new HandleSetNumPositionsOnScreen(setNumPositionsOnScreen));
            }
            else
            {

                if (this.inspectablePivotGrid1 == null || this.inspectablePivotGrid1.tabControl == null || this.inspectablePivotGrid1.tabControl.TabPages == null)
                    return;

                var tabPages = this.inspectablePivotGrid1.tabControl.TabPages;


                //once we have multiple tabs, this implementation needs to change to have separete count for each tab
                foreach (XtraTabPage xtp in tabPages)
                {
                    if (xtp is TabPageWithUomPivot)
                    {
                        var tabPage = xtp as TabPageWithUomPivot;
                        tabPage.setNumberPositions(this.inspectablePivotGrid1.NumPositionsOnScreen);

                    }
                }
            }
        }


        
        void riskForm_worker_DoWork(object sender, DoWorkEventArgs e)
        {
           

            /*
            if (InvokeRequired)
                this.Invoke(new MethodInvoker(() => refreshScreenWhenTreeSelectionChanges()));
            else
                refreshScreenWhenTreeSelectionChanges();
            */


            refreshScreenWhenTreeSelectionChanges();

        }


        private void updatePortfolioPathInWindowDefinition()
        {
        
            string portfolioPath = getSelectedPortfolioPath(this.treeList1);
            if (string.Compare(portfolioPath, windowDef.portfolioPath) != 0)
                windowDef.portfolioPath = portfolioPath;
         
        }

        void refreshScreenWhenTreeSelectionChanges()
        {
       

            int seqNum=0;

            lock(myLock)
            {
                maxSeqNum++;
                seqNum = maxSeqNum  ;
            }

            this.inspectablePivotGrid1.removePositionPivotProgressPanel();
            this.inspectablePivotGrid1.addPositionPivotGridProgressPanel();

            LocalPortfolio localPortfolio;
            TreeListNode selectedNode = null;
            int[] realPortfolioChildren = { 0 };
            int[] portfoliosForPNL = { 0 };
            int parentPortfolioNum = 0;
            java.lang.Integer[] localLatestPortfoliosForSubscription;

            lock (myLock)
            {

                if (this.treeList1 != null && this.treeList1.Selection != null && this.treeList1.Selection.Count > 0)
                {
                    selectedNode = this.treeList1.Selection[0];
                    updatePortfolioPathInWindowDefinition();
                }
            }

            lock (myLock)
            {
                if (seqNum != maxSeqNum)
                    return;

            }

            lock (myLock)
            {
                if (selectedNode != null && (localPortfolio = selectedNode.GetValue("Data") as LocalPortfolio) != null)
                {
                    parentPortfolioNum = localPortfolio.portNum;
                    portfoliosForPNL[0] = parentPortfolioNum;

                    lock (dataSourceLock)
                    {
                        this.inspectablePivotGrid1.clearAllDataSources();
                    }

                    this.inspectablePivotGrid1.NumPositionsOnScreen = 0;
                    if (InvokeRequired)
                    {
                        this.Invoke(new MethodInvoker(removeSelectionStuff));
                        this.Invoke(new MethodInvoker(() => setNumPositionsOnScreen())); // real number set on "update positions"
                    }
                    else
                    {
                        this.inspectablePivotGrid1.NumPositionsOnScreen = 0;
                        removeSelectionStuff();
                        setNumPositionsOnScreen();
                    }


                    if (localPortfolio.portType == "R")
                        realPortfolioChildren[0] = parentPortfolioNum;
                    else
                        realPortfolioChildren = getRealChildrenPortfolios(new java.lang.Integer(parentPortfolioNum));



                    this.inspectablePivotGrid1.NumRealPortfoliosOnScreen = realPortfolioChildren.Length;

                    if (this.InvokeRequired)
                        this.Invoke(new MethodInvoker(() => this.setRealPortfolioCountOnScreen()));
                    else
                        this.setRealPortfolioCountOnScreen();

                    logPortSelection(parentPortfolioNum, realPortfolioChildren, seqNum);

                }

                lock (myLock)
                {
                    if (seqNum != maxSeqNum)
                        return;

                }


                lock (myLock)
                {
                    latestPortfoliosForSubscription = SharedContext.makeVector(realPortfolioChildren);
                    localLatestPortfoliosForSubscription = latestPortfoliosForSubscription;

                    foreach (XtraTabPage xtp in this.inspectablePivotGrid1.tabControl.TabPages)
                    {
                        if (xtp is TabPageWithUomPivot)
                        {
                            TabPageWithUomPivot tabPage = xtp as TabPageWithUomPivot;
                            tabPage.isTabAlreadyOpened = false;

                            tabPage.realPortfoliosList = localLatestPortfoliosForSubscription;

                        }
                    }
                }

                lock (myLock)
                {
                    if (seqNum != maxSeqNum)
                        return;

                }


                lock (myLock)
                {

                    try
                    {
                        PositionEntityCacheImpl.Builder.positionCache().registerPortfolios(this, localLatestPortfoliosForSubscription, seqNum);
                    }
                    catch (Exception e2)
                    {

                        setStatusBarMessage(e2.ToString(), false);
                    }

                }

                lock (myLock)
                {
                    if (seqNum != maxSeqNum)
                        return;

                }

                lock (myLock)
                {

                    if (this.inspectablePivotGrid1.InvokeRequired)
                        this.Invoke(new MethodInvoker(() => this.inspectablePivotGrid1.setPLRecords(SharedContext.readPLRecords(portfoliosForPNL))));
                    else
                        this.inspectablePivotGrid1.setPLRecords(SharedContext.readPLRecords(portfoliosForPNL));
                }

            }
        }

        void treelistSelectionChanged()
        {
            isInitialReloadForPortfolio = true;
            stopDisplayTimer();

            if (riskForm_worker.IsBusy)
                riskForm_worker.CancelAsync();
            
            if (!riskForm_worker.IsBusy)
            {
                //BackGroung Worker Thread
                riskForm_worker.RunWorkerAsync();
            }
        }

        public void rabbitMQStatusChecking()
        {
            //Checking for the RabbitMQ status
            if (ChannelUtil.shared != null && ChannelUtil.shared.connection != null && ((RabbitMQ.Client.Framing.Impl.Connection)(NSRiskManager.ChannelUtil.shared.connection)).IsOpen)
                this.rabbitMqStatusIcon.Enabled = true;
            else
                this.rabbitMqStatusIcon.Enabled = false;
        }

        /// <summary>Target of portfolio selection-change.</summary>
        /// <param name="e"></param>
        /// <seealso cref="removeSelectionStuff"/>
        void treelistSelectionChanged(FocusedNodeChangedEventArgs e)
        {
          
            if (forcingInitialSelection)
            { 
                return;
            }

            treelistSelectionChanged();
            
        }


        static void logPortSelection(int portNum,int[] realKids,int thisSeqNum) {
            StringBuilder sb = new StringBuilder();
            int n;

            sb.Append("[request #" + thisSeqNum + "] children of " + portNum + ":");
            if ((n = realKids.Length) < 1)
                sb.Append("NONE");
            else
                for (int i = 0 ;i < n ;i++) {
                    if (i > 0)
                        sb.Append(",");
                    sb.Append(realKids[i]);
                }
            Debug.Print(sb.ToString());
        }

       

        /// <summary>de-select.</summary>
        void removeSelectionStuff() {
             this.inspectablePivotGrid1.removeSelection();
        }

   void doShutdown() {
       
            
        }    

        void displayStatusText(BarStaticItem bsi,string msg) {
            if (InvokeRequired)
                this.Invoke(new HandleStatusText(displayStatusText),bsi,msg);
            else
                if (bsi != null)
                    bsi.Caption = msg;
        }

        TabPageWithUomPivot currentTabPage() {
            return this.inspectablePivotGrid1.selectedPage();
        }

        void setupUI(PivotGridControl pgc) 
        {
            if (pgc == null)
                throw new ArgumentNullException("pgc",typeof(PivotGridControl).Name + " is null!");

            pgc.FieldTooltipShowing += new PivotFieldTooltipShowingEventHandler(pivotFieldToolTipShowingEventHandler);

           
            stopDisplayTimer();
            
            this.inspectablePivotGrid1.addPositionPivotGridProgressPanel();

            this.currentTabPage().setCurrentDataSource();
            
            if (!this.currentTabPage().isTabAlreadyOpened)
            {
                setTabReLoadStatus(this.currentTabPage().Text, true);
                RedrawOrReloadGrid();
            }
            startDisplayTimer();
            
        }


        void pivotFieldToolTipShowingEventHandler(object sender, PivotFieldTooltipShowingEventArgs e )
        {
            string  text = e.Text;
            

            if (e.ShowTooltip &&  text=="N/A")//Tooltip contains garbage
            {
                e.Text = "Unable to convert data to specified units or data not found";
            }
        }

        internal void setSplitterPosition(int p) {
            this.splitContainerControl1.SplitterPosition = p;
        }

        internal static RiskManagerForm fromDatabase(string aWinName) {
            return new RiskManagerForm(WinDefContext.createWindowDefinition(aWinName), false, 0);
        }

        internal void saveLayoutToDatabase() {

            saveLayoutToWindowDefinition();
            windowDef.saveChanges();
            
        }

        public void saveLayoutToDatabaseWithoutPrompting()
        {
            saveLayoutToWindowDefinition();
            windowDef.saveChangesWithoutPrompting();
        }


        private void saveLayoutToWindowDefinition()
        {
            IWindowLayoutProvider iwlp = this as IWindowLayoutProvider;
            string tmp;
            tmp = getSelectedPortfolioPath(this.treeList1);
            if (string.Compare(tmp, windowDef.portfolioPath) != 0)
                windowDef.portfolioPath = tmp;

            int selectedIndex = this.inspectablePivotGrid1.tabControl.SelectedTabPageIndex;
            if (selectedIndex != windowDef.selectedIndex)
                windowDef.selectedIndex = selectedIndex;

            this.inspectablePivotGrid1.updateWindowStateDefinitions(this.windowDef);
        }

        public void saveChangesWihoutPrompting()
        {
            windowDef.saveChangesWithoutPrompting();
        }

       

        LocalPortfolio selectedNodeIn(TreeList treeList)
        {
            TreeListMultiSelection sel;

            if ((sel = this.treeList1.Selection) != null && sel.Count > 0)
            {
                LocalPortfolio data = sel[0].GetValue("Data") as LocalPortfolio;
                return data;
            }
            return null;
        }

        void createPortfolio(PortfolioEditAction action)
        {
            try
            {
                LocalPortfolio lp;
                PortfolioEditor pe;
                DialogResult dr;
                Portfolio newCopy;
                int parentNum;

                if ((lp = selectedNodeIn(this.treeList1)) != null)
                {
                    if (action == PortfolioEditAction.NEW)
                    {
                        newCopy = PortfolioEditor.createDefaultPortfolio();
                        parentNum = lp.portNum;

                        pe = new PortfolioEditor(
                        action,
                        newCopy,
                        parentNum,
                        findSelectedPortfolioPath(this.treeList1, false), "N", null);

                    }
                    else
                    {
                        newCopy = deepCopyPortfolio(lp);
                        parentNum = findParentPortNum(this.treeList1);

                        pe = new PortfolioEditor(
                        action,
                        newCopy,
                        parentNum,
                        findSelectedPortfolioPath(this.treeList1, false), lp.IsLinkedIndicator, lp.PortfolioTags);
                    }

                    dr = pe.ShowDialog();
                    if (dr.Equals(DialogResult.OK))
                        setStatusBarMessage("Portfolio created successfully.", true);
                    else if (dr.Equals(DialogResult.Cancel))
                        setStatusBarMessage("Portfolio creation cancelled.", true);
                }
            }
            catch (Exception e)
            {
                setStatusBarMessage(e.Message, false);
            }
        }



        Portfolio deepCopyPortfolio(LocalPortfolio lp)
        {
            Portfolio src, newCopy;

            newCopy = copyBasicPortfolio(src = lp.realPortfolio);
            return newCopy;
        }

      

        static Portfolio copyBasicPortfolio(Portfolio src) {
            Portfolio newCopy;

            newCopy = new Portfolio();
            if (src.getCmntNum() != null)
                newCopy.setCmntNum(src.getCmntNum());
            newCopy.setDesiredPlCurrCode(src.getDesiredPlCurrCode());
            newCopy.setNumHistoryDays(src.getNumHistoryDays());
            newCopy.setOwnerInit(src.getOwnerInit());
            //newCopy.setPortClass(src.getPortClass());
            // for now, always send the portfolio class as "P"
            newCopy.setPortClass("P");

            newCopy.setPortFullName("Copy of " + src.getPortFullName());
            newCopy.setPortLocked(src.getPortLocked());
            newCopy.setPortRefKey(src.getPortRefKey());
            newCopy.setPortShortName("Copy of " + src.getPortShortName());
            newCopy.setPortType(src.getPortType());

            if (src.getTradingEntityNum() != null)
                newCopy.setTradingEntityNum(src.getTradingEntityNum());
            newCopy.setTransId(src.getTransId());
            return newCopy;
        }

        static string findSelectedPortfolioPath(TreeList tl,bool someArg) {
            string ret = "FIX THIS";
            TreeListNode tlnParent;
            StringBuilder sb = new StringBuilder();
            LocalPortfolio lp;
            List<string> tmp = new List<string>();

            if ((tlnParent = tl.Selection[0]) != null) {
                while (tlnParent != null) {
                    lp = tlnParent.GetValue("Data") as LocalPortfolio;
                    tmp.Add(lp.portShortName);
                    tlnParent = tlnParent.ParentNode;
                }
            }
            if (tmp.Count > 1)
                tmp.Reverse();
            ret = "/ " + string.Join(" / ",tmp.ToArray());
            return ret;
        }

        int findParentPortNum(TreeList tl)
        {
            TreeListMultiSelection sel;
            TreeListNode tlnParent;
            LocalPortfolio lpParent;

            if (tl != null && (sel = tl.Selection) != null && sel.Count > 0)
                if ((tlnParent = sel[0].ParentNode) != null)
                {
                    if ((lpParent = tlnParent.GetValue("Data") as LocalPortfolio) != null)
                        return lpParent.portNum;
                }
            return Int32.MinValue;
        }

       

        #endregion other methods

        #endregion

        #region drag-methods

        DragDropEffects GetDragDropEffect(TreeList tl,TreeListNode dragNode,int keyState) {
            TreeListNode targetNode;
            
            Point p = tl.PointToClient(MousePosition);
            targetNode = tl.CalcHitInfo(p).Node;

            if (targetNode == null)
                return DragDropEffects.None;

            var isChild = isNodeChildOf(dragNode,targetNode);

            var dragData = dragNode.GetValue("Data");
            var targetData = targetNode.GetValue("Data");

            LocalPortfolio dragNodeData = dragNode.GetValue("Data") as LocalPortfolio;
            LocalPortfolio targetNodeData = targetNode.GetValue("Data") as LocalPortfolio;


            bool hasCycle = HasCycle(dragNodeData, targetNodeData);
            Console.WriteLine("************* has cycle  = " +  hasCycle);

            //For links
            // 1) Link to anything that is not within the same parent hieranrchy
            // 2) Don't link upwards
            // 3) Make sure there are no cycles
            if (keyState == 9) {
                // CTRL PRESSED

                if (dragNode != null && targetNode != null
                    && dragNode != targetNode
                    && targetNodeData.portType != "R" // don't move to a real portfolio, drag and drop under its parent instead
                    && dragNode.ParentNode != targetNode
                    && !isNodeChildOf(dragNode,targetNode)
                    && !HasCycle(dragNodeData, targetNodeData))
                {
                    return DragDropEffects.Copy;
                }

            }

           // For moves:
           // 1) Don't move to yourself (same parent)
           // 2) Move whole structure
           // 3) make sure there are no cycles
            else if (keyState == 1) {
                if (dragNode != null && targetNode != null
                    && dragNode != targetNode
                    && dragNode.ParentNode != targetNode //don't move within the same parent
                    && targetNodeData.portType != "R" // don't move to a real portfolio, drag and drop under its parent instead
                    && (!HasCycle(dragNodeData, targetNodeData)))
                    //check if it's a real porfolio
                    return DragDropEffects.Move;
            }

            return DragDropEffects.None;
        }

        private bool isNodeChildOf(TreeListNode node1,TreeListNode node2) {
            if (node1 == node2)
                return false;
            TreeListNode node1ParentNode = node1.ParentNode;
            do {
                if (node1ParentNode == node2)
                    return true;
                if(node1ParentNode != null)
                    node1ParentNode = node1ParentNode.ParentNode;

            } while (node1ParentNode != null);

            return false;
        }


        void treeList_BeforeExpand(object sender, DevExpress.XtraTreeList.NodeEventArgs  e)
        {
           
            TreeListNode node = e.Node;
            var portfolioData = node.GetValue("Data") as LocalPortfolio;

            if (portfolioData != null)
                loadCachedChildrenNodesForPortfolio(portfolioData.portNum);

        }

        void treelist1_MouseDown(object sender, MouseEventArgs e)
        {

          
            TreeList tree = sender as TreeList;
            TreeListHitInfo hitInfo = tree.CalcHitInfo(e.Location);
            if (e.Button == MouseButtons.Right && hitInfo.HitInfoType == HitInfoType.Cell)
                hitInfo.Node.Selected = !hitInfo.Node.Selected;
        }


        void treeList1_DragOver(object sender,System.Windows.Forms.DragEventArgs e) {

           
            TreeListNode dragNode = e.Data.GetData(typeof(TreeListNode)) as TreeListNode;
            e.Effect = GetDragDropEffect(sender as TreeList,dragNode,e.KeyState);
        }

        void treeList1_DragDrop(object sender,System.Windows.Forms.DragEventArgs e) {

            TreeListNode dragNode,targetNode;
            TreeList tl = sender as TreeList;
            Point p = tl.PointToClient(new Point(e.X,e.Y));

            dragNode = e.Data.GetData(typeof(TreeListNode)) as TreeListNode;
            targetNode = tl.CalcHitInfo(p).Node;

            tl.SetNodeIndex(dragNode,tl.GetNodeIndex(targetNode));

            if (e.Effect == DragDropEffects.Copy)
                updatePortfolioOnLink(dragNode,targetNode);
            else if (e.Effect == DragDropEffects.Move)
                updatePortfolioOnMove(dragNode,targetNode);
            e.Effect = DragDropEffects.None;


        }

        private void updatePortfolioOnLink(TreeListNode dragNode, TreeListNode targetNode)
        {


            LocalPortfolio dragNodeData = dragNode.GetValue("Data") as LocalPortfolio;
            LocalPortfolio targetNodeData = targetNode.GetValue("Data") as LocalPortfolio;

            var portfolioNum = new java.lang.Integer(dragNodeData.portNum);
            var parentPortfolioNum = new java.lang.Integer(targetNodeData.portNum);

            var portfolioSupport = PortfolioEntityDTOSupportImpl.Builder.portfolioSupport();


            portfolioSupport.moveOrLinkPortfolio(portfolioNum, parentPortfolioNum, "Y");


        }

        private void updatePortfolioOnMove(TreeListNode dragNode,TreeListNode targetNode) 
        {
            LocalPortfolio dragNodeData = dragNode.GetValue("Data") as LocalPortfolio;
            LocalPortfolio targetNodeData = targetNode.GetValue("Data") as LocalPortfolio;

            var portfolioNum = new java.lang.Integer(dragNodeData.portNum);
            var parentPortfolioNum = new java.lang.Integer(targetNodeData.portNum);

            var portfolioSupport = PortfolioEntityDTOSupportImpl.Builder.portfolioSupport();

            portfolioSupport.moveOrLinkPortfolio(portfolioNum,parentPortfolioNum,"N");


        }

        void treeList1_CalcNodeDragImageIndex(object sender,DevExpress.XtraTreeList.CalcNodeDragImageIndexEventArgs e) {

            var dragArgs = e.DragArgs;

            TreeList tl = sender as TreeList;

            if (tl.FocusedNode == null)
                return;

            DragDropEffects dragDropEffect = GetDragDropEffect(tl,tl.FocusedNode,dragArgs.KeyState);

            if (dragDropEffect == DragDropEffects.Move)
                e.ImageIndex = 1;  // arrow Icon icon
            else if (dragDropEffect == DragDropEffects.Copy)
                e.ImageIndex = 3;  // link icon
            else
                e.ImageIndex = -1; //no icon, cannot move

        }


        #endregion drag-methods


        void setMainDataSourceForAllTabsWithoutReload(object sender, List<RiskGroup> ret)
        {

            foreach (XtraTabPage xtp in this.inspectablePivotGrid1.tabControl.TabPages)
            {
                if (xtp is TabPageWithUomPivot)
                {
                 
                    TabPageWithUomPivot tabPage = xtp as TabPageWithUomPivot;
                    tabPage.MainDataSource = ret;
                  
                }
            }
        }


      
        internal void registerSelection() {
            Util.show(MethodBase.GetCurrentMethod());
        }

        #region IPositionContainer implementation
        #endregion IPortfolioContainer implementation

        void IPositionContainer.updatedPositions(JLIST positions,int requestId) 
        {
            try
            {
                bool isRealTimeUpdate = false;
                if (requestId == 0)
                {
                    isRealTimeUpdate = true;
                }

                else if (maxSeqNum != requestId)
                {
                    return;//To skip the unrelated Positons for the selecterd portfolio
                }

                //we switched the portfolios, so remove all previous data that we got for the previous portfolio
                if (!isRealTimeUpdate)
                {
                    this.inspectablePivotGrid1.clearAllDataSources();
                }

                this.inspectablePivotGrid1.NumPositionsOnScreen = positions.size();
                setNumPositionsOnScreen();

                List<RiskGroup> ret = new List<RiskGroup>();
                RiskGroup  riskGroupFound;
                int n;
                bool markForRedraw = false;
                bool markForReload = false;

                List<IPositionEntity> iPosEntityLst = new List<IPositionEntity>();
                if (positions != null && (n = positions.size()) > 0)
                {

                    Dictionary<string, RiskGroup> dataSourceDict = new Dictionary<string, RiskGroup>();

                    List<RiskGroup> mainDataSource = this.inspectablePivotGrid1.MainDataSource as List<RiskGroup>;
                    foreach(RiskGroup dataSourceRiskGroup in mainDataSource)
                        dataSourceDict.Add(dataSourceRiskGroup.HashKey(), dataSourceRiskGroup);


                    for (int i = 0; i < n; i++)
                    {
                        lock (myLock)
                        {
                            //every few iterations do a sanity check
                            if (i % 100 == 0)
                            {
                                // portfolio was switched to a new one while painting was in progress
                                // so let's discard all the changes.
                                if (!isRealTimeUpdate && maxSeqNum != requestId)
                                {
                                    this.inspectablePivotGrid1.clearAllDataSources();
                                    return;
                                }
                            }
                        }

                            findRiskGroup =  new RiskGroup(positions.get(i) as IPositionEntity);

                            if (findRiskGroup.positionNumber == 0)
                                continue;

                            // all atoms were excluded, so exclude the risk group
                            if (findRiskGroup.atoms.Count == 0)
                                continue;

                            if(isRealTimeUpdate)
                            {
                                //ignore real-time updates for portfolios that we are not subcribed to.

                                java.lang.Integer portfolioToFind = new java.lang.Integer(findRiskGroup.portfolio);
                                if (!latestPortfoliosForSubscription.Contains(portfolioToFind))
                                    continue;
                            }

                            lock (dataSourceLock)
                            {

                                riskGroupFound = null;

                                try
                                {
                                    riskGroupFound = dataSourceDict[findRiskGroup.HashKey()];
                                }
                                catch (Exception ex)
                                {
                                    //it's ok if risk group was not found
                                }
                                
                                if (riskGroupFound != null)
                                {
                                    riskGroupFound.merge(findRiskGroup);

                                     if (isInitialReloadForPortfolio)
                                         markAllTabsInRiskGroupDirty(riskGroupFound, false);
                                     else
                                         markAllTabsInRiskGroupDirty(riskGroupFound, true);
                                    markForReload = true;
                                    
                                    //markForRedraw = true;
                                   

                                }
                                else
                                {
                                      if (isInitialReloadForPortfolio)
                                          markAllTabsInRiskGroupDirty(findRiskGroup, false);
                                     else
                                         markAllTabsInRiskGroupDirty(findRiskGroup, true);

                                    dataSourceDict.Add(findRiskGroup.HashKey(), findRiskGroup);
                                    markForReload = true;

                                }


                        }
                    }

                    

                    if( markForRedraw)
                        markAllTabsForRedraw();
                    if(markForReload)
                        markAllTabsForReload();   
 
                    List<RiskGroup>  dictValues = dataSourceDict.Values.ToList() as List<RiskGroup>;
                    this.inspectablePivotGrid1.MainDataSource = dictValues;

                }


                
                lock (dataSourceLock)
                    ret.AddRange(this.inspectablePivotGrid1.MainDataSource);
               
                
               
                if (InvokeRequired)
                    this.Invoke(new SetDatasourceDelegate(setMainDataSourceForAllTabsWithoutReload), this, ret);
                else
                    setMainDataSourceForAllTabsWithoutReload(this, ret);
                 

               TabPageWithUomPivot tabPage =   this.inspectablePivotGrid1.tabControl.SelectedTabPage as TabPageWithUomPivot;

                //it's possible that there are zero tab pages
               if (tabPage != null)
               {
                   tabPage.setCurrentDataSource();


                   if (isInitialReloadForPortfolio)
                   {
                       if (InvokeRequired)
                           this.Invoke(new MethodInvoker(() => requestCurrentPivotgridReload(tabPage.Text)));
                       else
                           requestCurrentPivotgridReload(tabPage.Text);
                       isInitialReloadForPortfolio = false;
                   }
               }
               else
               {
                   this.inspectablePivotGrid1.removePositionPivotProgressPanel();

               }


                startDisplayTimer();
            }

            catch(Exception e)
            {
                Console.WriteLine("exception in updatedPositions");
                Console.WriteLine(e.ToString());
                setStatusBarMessage(e.Message, false);
            }
        }


        private void markAllTablsInAllRiskGroupsDirty()
        {

            string[] riskFields = { "riskQty", "physQty", "discountQty" };

            List<RiskGroup> riskGroups = this.inspectablePivotGrid1.MainDataSource as List<RiskGroup>;

            foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
            {

                if (xtraTabPage is TabPageWithUomPivot)
                {
                    //needs to be cached since it takes a long time to access it.
                    string xtraTabPageText = xtraTabPage.Text;

                    foreach (string riskField in riskFields)
                    {

                        foreach (RiskGroup riskGroup in riskGroups)
                             riskGroup.setTabDirtyStatus(xtraTabPageText + riskField, true);

                    }
                }
            }
        }
     

        private void markAllTabsInRiskGroupDirty(RiskGroup riskGroup, bool status)
        {
            
            string[] riskFields = { "riskQty", "physQty", "discountQty" };
            
            foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
            {
               
                if (xtraTabPage is TabPageWithUomPivot)
                {
                    //needs to be cached since it takes a long time to access it.
                    string xtraTabPageText = xtraTabPage.Text;

                    foreach (string riskField in riskFields)
                    {

                        riskGroup.setTabDirtyStatus(xtraTabPageText + riskField, status);
                      
                    }
                }
            }


        }


        private void markAllTabsForRedraw()
        {

            foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
            {
                if (xtraTabPage is TabPageWithUomPivot)
                {
                    setTabReDrawStatus(xtraTabPage.Text, true);
                }
            }
        }

        private void markAllTabsForReload()
        {
            foreach (XtraTabPage xtraTabPage in this.inspectablePivotGrid1.tabControl.TabPages)
            {
                if (xtraTabPage is TabPageWithUomPivot)
                {
                    setTabReLoadStatus(xtraTabPage.Text, true);
                }
            }
        }

        void IPortfolioContainer.deletedPortfolio(JLIST deletedPortIds, string message, string refId)
        {
            deletedPortfolio( deletedPortIds,  message,  refId);
        }

        void deletedPortfolio(JLIST deletedPortIds, string message, string refId)
        {
      
            if (this.InvokeRequired)
            {
                this.Invoke(new HandleDeletedPortfolio(deletedPortfolio), deletedPortIds, message, refId);
            }
            else
            {
                Array deletedPortfolios = deletedPortIds.toArray();

                foreach (IPortfolioEntityDTO deletedPortfolio in deletedPortfolios)
                {
                    java.lang.Integer portfolioId = deletedPortfolio.getPortNum();
                    java.lang.Integer parentPortfolioId = deletedPortfolio.getParentPortId();

                    deleteNodeFrom(parentPortfolioId.intValue(), portfolioId.intValue());
                }

                
                treeList1.Refresh();
            }

            
        }

        void IUomContainer.updateUom(IUomEntity iue) {
            Util.show(MethodBase.GetCurrentMethod());
        }
        void IUomContainer.updateUomConversion(IUomConversionEntity iuce) {
            Util.show(MethodBase.GetCurrentMethod());
        }


        void IPortfolioContainer.insertedPortfolio(JLIST inserted, JMAP allSiblingsAndRelatives, JMAP topicsAssociated, string message, string refId)
        {
            
            insertedPortfolio( inserted,  allSiblingsAndRelatives,  topicsAssociated,  message,  refId);
        }

        void insertedPortfolio(JLIST inserted, JMAP allSiblingsAndRelatives, JMAP topicsAssociated, string message, string refId)
        {


            if (InvokeRequired)
            {
                this.Invoke(new HandleInsertedPortfolio(insertedPortfolio), inserted, allSiblingsAndRelatives, topicsAssociated, message, refId);
            }
            else
            {
                try
                {

                    Util.show(MethodBase.GetCurrentMethod());

                    Array insertedList = inserted.toArray();
                    foreach (var insertedObject in insertedList)
                    {
                        PortfolioDTO portfolioDTO = insertedObject as PortfolioDTO;

                        java.lang.Integer parentportIdJava = portfolioDTO.getParentPortId();
                        int parentPortId;

                        if (parentportIdJava == null || parentportIdJava.intValue() <= 0)
                        {
                            // insert at the parent level
                            insertNodeInto(portfolioDTO, null);

                        }
                        else
                        {
                            parentPortId = portfolioDTO.getParentPortId().intValue();
                            int portId = portfolioDTO.getParentPortId().intValue();

                            int[] grandparentIds = findAllParentsForPortfolio(parentPortId);

                            foreach (int grandParentId in grandparentIds)
                            {
                                List<int> parentNodeIds = findTreeNodeIdsForPortfolioId(parentPortId, grandParentId);

                                if(parentNodeIds.Count ==  0)
                                    continue;

                                foreach (int parentNodeId in parentNodeIds)
                                {
                                    TreeListNode rootNode = treeList1.FindNodeByFieldValue("UniqueID", parentNodeId);

                                    if (rootNode == null)
                                        continue;

                                    insertNodeInto(portfolioDTO, rootNode);
                                }
                            }

                        }

                    }

                    treeList1.Refresh();
                }
                catch(Exception ex)
                {
                
                }
            
        }
            
       
        }


        void IPortfolioContainer.updatedPortfolio(JLIST updated, JMAP allSiblingsAndRelatives, JMAP topicsAssociated, string message, string refId)
        {
           
            updatedPortfolio( updated,  allSiblingsAndRelatives,  topicsAssociated,  message,  refId);
        }
       
        void updatedPortfolio(JLIST updated, JMAP allSiblingsAndRelatives, JMAP topicsAssociated, string message, string refId)
        {
            if (InvokeRequired)
            {
                this.Invoke(new HandleUpdatedPortfolio(updatedPortfolio), updated, allSiblingsAndRelatives, topicsAssociated, message, refId);
            }
            else
            {
             


                Array insertedList = updated.toArray();
                foreach (var insertedObject in insertedList)
                {
                    PortfolioDTO portfolioDTO = insertedObject as PortfolioDTO;


                    /*
                     * int parentPortId;
                    java.lang.Integer parentPortIdJava = portfolioDTO.getParentPortId();
                   
                    if (parentPortIdJava == null)
                    {
                        parentPortId = java.lang.Integer.MIN_VALUE;
                    }
                    else
                    {
                        parentPortId = portfolioDTO.getParentPortId().intValue();
                    }
                    */


                    int portId = portfolioDTO.getPortNum().intValue();
                    int [] parentPortIds = findAllParentsForPortfolio(portId);


                    foreach (int parentPortId in parentPortIds)
                    {
                        List<int> nodeIds = findTreeNodeIdsForPortfolioId(portId, parentPortId);


                        foreach (int nodeId in nodeIds)
                        {
                            TreeListNode node = treeList1.FindNodeByFieldValue("UniqueID", nodeId);

                            if (node != null)
                                updateNode(portfolioDTO, node);
                        }
                    }

                }

              
            }
        }

        string getPortIdKey(int portId, int parentPortId)
        {
            return portId + ":" + parentPortId;
        }

        private List<int> findTreeNodeIdsForPortfolioId(string portidKey)
        {
            List<int> nodeIds = new List<int>();

            bool found = portIdToNodeIDMapping.TryGetValue(portidKey, out nodeIds);

            if (!found)
                nodeIds = new List<int>();

            return nodeIds;

        }

        private List<int> findTreeNodeIdsForPortfolioId(int portId, int parentPortId)
        {
            return findTreeNodeIdsForPortfolioId(getPortIdKey(portId, parentPortId));
        }

        private LocalPortfolio DTOToLocalPortfolio(PortfolioDTO portfolioDTO)
        {
            Portfolio portfolio = new Portfolio();

            portfolio.setCmntNum(portfolioDTO.getCmntNum());
            portfolio.setDesiredPlCurrCode(portfolioDTO.getDesiredPlCurrCode());
            portfolio.setNumHistoryDays(portfolioDTO.getNumHistoryDays());
            portfolio.setOwnerInit(portfolioDTO.getOwnerInit());

            // for now, always send the portfolio class as "P"
            portfolio.setPortClass("P");
            //portfolio.setPortClass(portfolioDTO.getPortClass());
            
            portfolio.setPortFullName(portfolioDTO.getPortFullName());
            portfolio.setPortLocked(portfolioDTO.getPortLocked());
            portfolio.setPortNum(portfolioDTO.getPortNum());
            portfolio.setPortRefKey(portfolioDTO.getPortRefKey());
            portfolio.setPortShortName(portfolioDTO.getPortShortName());
            portfolio.setPortType(portfolioDTO.getPortType());
            portfolio.setTradingEntityNum(portfolioDTO.getTradingEntityNum());
            portfolio.setTransId(portfolioDTO.getTransId());

            var transId = portfolioDTO.getTransId();

            LocalPortfolio localPorfolio = new LocalPortfolio(portfolio);
            localPorfolio.IsLinkedIndicator = portfolioDTO.getLinkInd();
            
            
            java.util.Set portfolioDTOTags = portfolioDTO.getPortfolioTags().tags;
            localPorfolio.PortfolioTags = portfolioDTOTags;

            java.lang.Integer parentPortIdJava = portfolioDTO.getParentPortId();

            if (parentPortIdJava == null)
            {
                localPorfolio.parentId = java.lang.Integer.MIN_VALUE;
            }
            else
            {
                localPorfolio.parentId = portfolioDTO.getParentPortId().intValue();
            }

            return localPorfolio;
        }


        private void deleteNodeFrom(int parentPortId, int portNum)
        {

            try
            {

                List<int> nodeIds = findTreeNodeIdsForPortfolioId(portNum, parentPortId);

                List<int> nodeIdsCopy = new List<int>(nodeIds);

                foreach (int nodeId in nodeIdsCopy)
                {

                    TreeListNode node = treeList1.FindNodeByFieldValue("UniqueID", nodeId);

                    if (node == null)
                    {
                        continue;
                    }

                    var data = node.GetValue("Data") as LocalPortfolio;

                    //delete only the records that were specified to be deleted. perhaps some of them are links
                    //so we don't want to delete them on the screen
                    if (data.parentId == parentPortId)
                    {
                        removePortIdToNodeMapping(portNum, parentPortId, nodeId);
                        this.treeList1.DeleteNode(node);

                    }
                }
            }
            catch (Exception ex)
            { 
            
            }
        }

        private void removePortIdToNodeMapping(int portNum, int parentPortdNum, int nodeId)
        {
            string key = getPortIdKey(portNum, parentPortdNum);

            if (portIdToNodeIDMapping.ContainsKey(key))
            {
                List<int> nodeIds = portIdToNodeIDMapping[key];

                nodeIds.Remove(nodeId);

               
            
            }
        }

        private void insertNodeInto(PortfolioDTO portfolioDTO, TreeListNode rootNode)
        {
            string shortName = portfolioDTO.getPortShortName();
            int portfolioNum = portfolioDTO.getPortNum().intValue();

            var parentPortfolioNumObject = portfolioDTO.getParentPortId();
            
            int parentPortfolioNum = Int32.MinValue;
            if(parentPortfolioNumObject!=null)
                parentPortfolioNum = parentPortfolioNumObject.intValue();

            LocalPortfolio localPortfolio = DTOToLocalPortfolio(portfolioDTO);


            int uniqueID = randomGenerator.Next();

            object[] data = { shortName, portfolioNum, localPortfolio,  uniqueID };

            TreeListNode treeNode = this.treeList1.AppendNode(data, rootNode);
          
            //var nodeId = treeNode.Id;

            //always default to children being set so that we see the expand button
            if (portfolioDTO.getPortType() != "R")
                treeNode.HasChildren = true;


            insertdPortIdToNodeMapping(portfolioNum, parentPortfolioNum, uniqueID);
        }

        private void updateNode(PortfolioDTO portfolioDTO, TreeListNode node)
        {
            string shortName = portfolioDTO.getPortShortName();
            int portfolioNum = portfolioDTO.getPortNum().intValue();

            LocalPortfolio oldLocalPortfolio =  node.GetValue("Data") as LocalPortfolio;

            string linkedIndicator = oldLocalPortfolio.IsLinkedIndicator;
            int parentPortId = oldLocalPortfolio.parentId;
            var  uniqueID = node.GetValue("UniqueID");

            LocalPortfolio localPortfolio = DTOToLocalPortfolio(portfolioDTO);
            
            // set the fields that differentiate the nodes from one another - parent and linked indicator
            localPortfolio.parentId = parentPortId;
            localPortfolio.IsLinkedIndicator = linkedIndicator;

            
            node.SetValue("Portfolio", shortName);
            node.SetValue("ID", portfolioNum);
            node.SetValue("Data", localPortfolio);
            node.SetValue("UniqueID", uniqueID);

            //always default to children being set so that we see the expand button
            if (portfolioDTO.getPortType() != "R")
                node.HasChildren = true;

          
        }


        private void insertdPortIdToNodeMapping(int portfolioNum, int parentPortfolioNum, int nodeId)
        {

            string key = getPortIdKey(portfolioNum, parentPortfolioNum);

            if (!portIdToNodeIDMapping.ContainsKey(key))
            {
                List<int> nodeIds = new List<int>();
                nodeIds.Add(nodeId);

                portIdToNodeIDMapping.Add(key, nodeIds);
            }
            else
            {
                List<int> nodeIds = portIdToNodeIDMapping[key];

                nodeIds.Add(nodeId);
            }
        }


        private bool isRightParentPortfolioToProcess(Array portfolioDTOs)
        { 
            //just look at the first portfolio, they should all have the same parent.
            if (portfolioDTOs.Length > 0)
            {
                PortfolioDTO portfolioDTO = portfolioDTOs.GetValue(0) as PortfolioDTO;

                int parentId = portfolioDTO.getParentPortId().intValue();

                // these are not the updates we were expecting for this screen, ingore them.
                if (parentId == portfolioIdToExpand)
                {
                    return true;
                }

            }

            return false;
        }

        private void createTopLevelTreeHierarchy(Array portfolioDTOs)
        {

            treeList1.Nodes.Clear();
            portIdToNodeIDMapping.Clear();
           
            foreach (PortfolioDTO portfolioDTO in portfolioDTOs)
            {
                int parentId = portfolioDTO.getParentPortId().intValue();

                insertNodeInto(portfolioDTO, null);
            }
        }

        private List<string> createChildrenForPortfolio( Array portfolioDTOs)
        {

            List<string> alreadyExpandedChildrenNodes = new List<string>();

            try
            {
                
                //ON THE FIRST PASS, JUST CLEAR THE PARENT NODES and remove port id to node mappings
                foreach (PortfolioDTO portfolioDTO in portfolioDTOs)
                {
                    int parentPortId = portfolioDTO.getParentPortId().intValue();
                    int[] grandparentIds = findAllParentsForPortfolio(parentPortId);

                    foreach (int grandParentId in grandparentIds)
                    {

                        List<int> parentPortNodeIds = findTreeNodeIdsForPortfolioId(parentPortId, grandParentId);
                        int portId = portfolioDTO.getPortNum().intValue();

                        foreach (int parentPortNodeId in parentPortNodeIds)
                        {
                            TreeListNode rootNode = treeList1.FindNodeByFieldValue("UniqueID", parentPortNodeId);

                            if (rootNode == null)
                                continue;


                            foreach (TreeListNode node in rootNode.Nodes)
                            {
                                //OKSANA_TODO
                                LocalPortfolio localPortfolio = node.GetValue("Data") as LocalPortfolio;
                                int localPortfolioId = localPortfolio.portNum;
                                int localPortfolioParentId = localPortfolio.parentId;
                                int nodeId = Convert.ToInt32(node.GetValue("UniqueID"));

                                if (node.Expanded == true)
                                    alreadyExpandedChildrenNodes.Add(getPortIdKey(localPortfolioId, localPortfolioParentId));

                                removePortIdToNodeMapping(localPortfolioId, localPortfolioParentId, nodeId);
                                //removePortIdToNodeMapping(portId, parentPortId);


                            }

                            rootNode.Nodes.Clear();
                            rootNode.HasChildren = true;
                        }
                    }

                }


                // NOW INSERT THE CHILDREN
                foreach (PortfolioDTO portfolioDTO in portfolioDTOs)
                {
                    int parentPortId = portfolioDTO.getParentPortId().intValue();

                    //int grandParentId = findParentForPortfolio(parentPortId);


                    int[] grandparentIds = findAllParentsForPortfolio(parentPortId);

                    foreach (int grandParentId in grandparentIds)
                    {

                        //Oksana_todo: optimize not to make this call twice
                        List<int>  parentPortNodeIds = findTreeNodeIdsForPortfolioId(parentPortId, grandParentId);

                        foreach (int parentPortNodeId in parentPortNodeIds)
                        {

                            TreeListNode rootNode = treeList1.FindNodeByFieldValue("UniqueID", parentPortNodeId);

                            if (rootNode == null)
                                continue;


                            // these are not the updates we were expecting for this screen, ingore them.
                            if (parentPortId != portfolioIdToExpand)
                            {
                                break;
                            }


                            insertNodeInto(portfolioDTO, rootNode);
                        }


                    }
                }

            }

            catch (Exception e)
            { 
            
            }

            return alreadyExpandedChildrenNodes;
        }

        void IPortfolioContainer.onPortfolioLoaded(java.util.Collection collection)
        {
            onPortfolioLoaded(collection);
        }

        void onPortfolioLoaded(java.util.Collection collection)
        {
           
            if (InvokeRequired)
            {
                this.Invoke(new HandleOnPortfolioLoaded(onPortfolioLoaded), collection);
            }
            else
            {
                //we are not expecting any portfolios to be loaded
                if (portfolioIdToExpand == -1)
                    return;

                var portfolios = collection.toArray();

                if (!isRightParentPortfolioToProcess(portfolios))
                    return;

                if (portfolios.Length <= 0)
                    return;

                string portType = (portfolios[0] as PortfolioDTO).getPortType();

                List<string> alreadyExpandedChildNodes = new List<string>();

                if (portType == "IW")
                {
                    
                    //onPortfolioLoaded is generated on different threads. avoid processing it on a thread that 
                    //already loaded the portfolio
                    if (!screenInitiallyLoaded)
                    {
                      
                            createTopLevelTreeHierarchy(portfolios);
                            screenInitiallyLoaded = true;
                       
                    }
                    portfolioHierarchyLoading = false;
                    newWindowOpening = false;
                }
                else
                {
                    alreadyExpandedChildNodes = createChildrenForPortfolio(portfolios);
                }

              

                ExpandCurrentNodeInDefaultPath(alreadyExpandedChildNodes);

               
            }
        }

        void IPortfolioContainer.onPortfolioRemoval(com.amphora.entities.dto.IPortfolioEntityDTO dto)
        {
         
        }
    }

    public enum PortfolioEditAction {
        NONE = -1,
        NEW,
        NEW_AS_COPY_OF,
        COPY,
        DELETE,
        UPDATE
    }
}